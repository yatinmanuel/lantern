import fs from 'fs/promises';
import { exec } from 'child_process';
import { promisify } from 'util';
import { PXEConfigModel } from '../database/models.js';
import { logger } from './logger.js';

const execAsync = promisify(exec);

export async function applyConfiguration(key: string, _value: string): Promise<void> {
  switch (key) {
    case 'pxe_server_ip':
    case 'pxe_server_port':
    case 'dhcp_interface':
    case 'dhcp_range':
      logger.info(`Configuration ${key} updated. Restart dnsmasq to apply.`);
      break;
    case 'ipxe_menu_path':
      break;
    default:
      break;
  }
}

export async function regenerateDnsmasqConfig(): Promise<{ path: string; content: string }> {
  const config = await PXEConfigModel.getAll();
  const configMap: Record<string, string> = {};
  config.forEach(item => {
    configMap[item.key] = item.value;
  });

  const pxeServerIp = configMap.pxe_server_ip || '192.168.1.10';
  const dhcpInterface = configMap.dhcp_interface || 'eth0';
  const dhcpRange = configMap.dhcp_range || '192.168.1.100,192.168.1.200,12h';
  const pxeServerPort = configMap.pxe_server_port || '3000';
  const webRoot = configMap.web_root || '/var/www/html';
  const ipxeMenuUrl = `http://${pxeServerIp}:${pxeServerPort}/ipxe/menu.ipxe`;

  const dnsmasqConfig = `# PXE Server Configuration
# Generated by Lantern

interface=${dhcpInterface}
dhcp-range=${dhcpRange}
dhcp-option=3,${pxeServerIp}
dhcp-option=6,${pxeServerIp}

enable-tftp
tftp-root=${webRoot}
pxe-service=x86PC,"Boot from network",pxelinux
pxe-service=x86-64_EFI,"Boot from network (UEFI)",ipxe.efi

dhcp-match=set:ipxe,175
dhcp-boot=tag:!ipxe,undionly.kpxe,${pxeServerIp},${pxeServerIp}
dhcp-boot=tag:ipxe,${ipxeMenuUrl}

log-dhcp
log-queries
port=0
`;

  const configPath = process.env.DNSMASQ_CONFIG_PATH;

  if (configPath) {
    await fs.writeFile(configPath, dnsmasqConfig);
    logger.info(`dnsmasq configuration regenerated at ${configPath}`);
    return { path: configPath, content: dnsmasqConfig };
  }

  await fs.writeFile('/tmp/dnsmasq.conf.pxe', dnsmasqConfig);
  return { path: '/tmp/dnsmasq.conf.pxe', content: dnsmasqConfig };
}

export async function restartDnsmasq(): Promise<void> {
  try {
    await execAsync('sudo systemctl restart dnsmasq');
    logger.info('dnsmasq restarted via systemctl');
    return;
  } catch {
    try {
      await execAsync('sudo service dnsmasq restart');
      logger.info('dnsmasq restarted via service');
      return;
    } catch (error: any) {
      logger.error('Failed to restart dnsmasq:', error);
      throw error;
    }
  }
}

export async function getDnsmasqStatus(): Promise<{ status: string; active: boolean; error?: string }> {
  try {
    const { stdout } = await execAsync('systemctl is-active dnsmasq');
    const isActive = String(stdout).trim() === 'active';
    return { status: isActive ? 'running' : 'stopped', active: isActive };
  } catch {
    try {
      const { stdout } = await execAsync('service dnsmasq status');
      const output = String(stdout);
      const isRunning = output.includes('running') || output.includes('active');
      return { status: isRunning ? 'running' : 'stopped', active: isRunning };
    } catch {
      return { status: 'unknown', active: false, error: 'Cannot determine dnsmasq status' };
    }
  }
}
